<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Welcome to TFTPy’s documentation! &mdash; TFTPy v0.5.1 documentation</title>
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '#',
        VERSION:     '0.5.1',
        COLLAPSE_MODINDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="TFTPy v0.5.1 documentation" href="#" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="modindex.html" title="Global Module Index"
             accesskey="M">modules</a> |</li>
        <li><a href="#">TFTPy v0.5.1 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="welcome-to-tftpy-s-documentation">
<h1>Welcome to TFTPy&#8217;s documentation!<a class="headerlink" href="#welcome-to-tftpy-s-documentation" title="Permalink to this headline">¶</a></h1>
<p>Contents:</p>
<ul class="simple">
</ul>
</div>
<div class="section" id="indices-and-tables">
<h1>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><a class="reference external" href="genindex.html"><em>Index</em></a></li>
<li><a class="reference external" href="modindex.html"><em>Module Index</em></a></li>
<li><a class="reference external" href="search.html"><em>Search Page</em></a></li>
</ul>
</div>
<div class="section" id="api-documentation">
<h1>API Documentation<a class="headerlink" href="#api-documentation" title="Permalink to this headline">¶</a></h1>
<div class="section" id="front-end-modules">
<h2>Front-end Modules<a class="headerlink" href="#front-end-modules" title="Permalink to this headline">¶</a></h2>
<p>These modules are the ones that you will need to use directly to implement a
TFTP client or server.</p>
<div class="section" id="module-tftpy">
<h3>TFTPy Module<a class="headerlink" href="#module-tftpy" title="Permalink to this headline">¶</a></h3>
<p>This library implements the tftp protocol, based on rfc 1350.
<a class="reference external" href="http://www.faqs.org/rfcs/rfc1350.html">http://www.faqs.org/rfcs/rfc1350.html</a>
At the moment it implements only a client class, but will include a server,
with support for variable block sizes.</p>
<p>As a client of tftpy, this is the only module that you should need to import
directly. The TftpClient and TftpServer classes can be reached through it.</p>
</div>
<div class="section" id="module-tftpy.TftpClient">
<h3>tftpy.TftpClient<a class="headerlink" href="#module-tftpy.TftpClient" title="Permalink to this headline">¶</a></h3>
<p>This module implements the TFTP Client functionality. Instantiate an
instance of the client, and then use its upload or download method. Logging is
performed via a standard logging object set in TftpShared.</p>
<dl class="class">
<dt id="tftpy.TftpClient.TftpClient">
<em class="property">class </em><tt class="descclassname">tftpy.TftpClient.</tt><tt class="descname">TftpClient</tt><big>(</big><em>host</em>, <em>port</em>, <em>options={}</em><big>)</big><a class="headerlink" href="#tftpy.TftpClient.TftpClient" title="Permalink to this definition">¶</a></dt>
<dd><p>This class is an implementation of a tftp client. Once instantiated, a
download can be initiated via the download() method, or an upload via the
upload() method.</p>
<dl class="method">
<dt id="tftpy.TftpClient.TftpClient.download">
<tt class="descname">download</tt><big>(</big><em>filename</em>, <em>output</em>, <em>packethook=None</em>, <em>timeout=5</em><big>)</big><a class="headerlink" href="#tftpy.TftpClient.TftpClient.download" title="Permalink to this definition">¶</a></dt>
<dd><p>This method initiates a tftp download from the configured remote
host, requesting the filename passed. It saves the file to a local
file specified in the output parameter. If a packethook is provided,
it must be a function that takes a single parameter, which will be a
copy of each DAT packet received in the form of a TftpPacketDAT
object. The timeout parameter may be used to override the default
SOCK_TIMEOUT setting, which is the amount of time that the client will
wait for a receive packet to arrive.</p>
<p>Note: If output is a hyphen then stdout is used.</p>
</dd></dl>

<dl class="method">
<dt id="tftpy.TftpClient.TftpClient.upload">
<tt class="descname">upload</tt><big>(</big><em>filename</em>, <em>input</em>, <em>packethook=None</em>, <em>timeout=5</em><big>)</big><a class="headerlink" href="#tftpy.TftpClient.TftpClient.upload" title="Permalink to this definition">¶</a></dt>
<dd><p>This method initiates a tftp upload to the configured remote host,
uploading the filename passed.  If a packethook is provided, it must
be a function that takes a single parameter, which will be a copy of
each DAT packet sent in the form of a TftpPacketDAT object. The
timeout parameter may be used to override the default SOCK_TIMEOUT
setting, which is the amount of time that the client will wait for a
DAT packet to be ACKd by the server.</p>
<p>Note: If output is a hyphen then stdout is used.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-tftpy.TftpServer">
<h3>tftpy.TftpServer<a class="headerlink" href="#module-tftpy.TftpServer" title="Permalink to this headline">¶</a></h3>
<p>This module implements the TFTP Server functionality. Instantiate an
instance of the server, and then run the listen() method to listen for client
requests. Logging is performed via a standard logging object set in
TftpShared.</p>
<dl class="class">
<dt id="tftpy.TftpServer.TftpServer">
<em class="property">class </em><tt class="descclassname">tftpy.TftpServer.</tt><tt class="descname">TftpServer</tt><big>(</big><em>tftproot='/tftpboot'</em>, <em>dyn_file_func=None</em><big>)</big><a class="headerlink" href="#tftpy.TftpServer.TftpServer" title="Permalink to this definition">¶</a></dt>
<dd><p>This class implements a tftp server object. Run the listen() method to
listen for client requests.  It takes two optional arguments. tftproot is
the path to the tftproot directory to serve files from and/or write them
to. dyn_file_func is a callable that must return a file-like object to
read from during downloads. This permits the serving of dynamic
content.</p>
<dl class="method">
<dt id="tftpy.TftpServer.TftpServer.listen">
<tt class="descname">listen</tt><big>(</big><em>listenip=''</em>, <em>listenport=69</em>, <em>timeout=5</em><big>)</big><a class="headerlink" href="#tftpy.TftpServer.TftpServer.listen" title="Permalink to this definition">¶</a></dt>
<dd>Start a server listening on the supplied interface and port. This
defaults to INADDR_ANY (all interfaces) and UDP port 69. You can also
supply a different socket timeout value, if desired.</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="back-end-modules">
<h2>Back-end Modules<a class="headerlink" href="#back-end-modules" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-tftpy.TftpPacketFactory">
<h3>tftpy.TftpPacketFactory<a class="headerlink" href="#module-tftpy.TftpPacketFactory" title="Permalink to this headline">¶</a></h3>
<p>This module implements the TftpPacketFactory class, which can take a binary
buffer, and return the appropriate TftpPacket object to represent it, via the
parse() method.</p>
<dl class="class">
<dt id="tftpy.TftpPacketFactory.TftpPacketFactory">
<em class="property">class </em><tt class="descclassname">tftpy.TftpPacketFactory.</tt><tt class="descname">TftpPacketFactory</tt><a class="headerlink" href="#tftpy.TftpPacketFactory.TftpPacketFactory" title="Permalink to this definition">¶</a></dt>
<dd><p>This class generates TftpPacket objects. It is responsible for parsing
raw buffers off of the wire and returning objects representing them, via
the parse() method.</p>
<dl class="method">
<dt id="tftpy.TftpPacketFactory.TftpPacketFactory.parse">
<tt class="descname">parse</tt><big>(</big><em>buffer</em><big>)</big><a class="headerlink" href="#tftpy.TftpPacketFactory.TftpPacketFactory.parse" title="Permalink to this definition">¶</a></dt>
<dd>This method is used to parse an existing datagram into its
corresponding TftpPacket object. The buffer is the raw bytes off of
the network.</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-tftpy.TftpPacketTypes">
<h3>tftpy.TftpPacketTypes<a class="headerlink" href="#module-tftpy.TftpPacketTypes" title="Permalink to this headline">¶</a></h3>
<p>This module implements the packet types of TFTP itself, and the
corresponding encode and decode methods for them.</p>
<dl class="class">
<dt id="tftpy.TftpPacketTypes.TftpPacket">
<em class="property">class </em><tt class="descclassname">tftpy.TftpPacketTypes.</tt><tt class="descname">TftpPacket</tt><a class="headerlink" href="#tftpy.TftpPacketTypes.TftpPacket" title="Permalink to this definition">¶</a></dt>
<dd><p>This class is the parent class of all tftp packet classes. It is an
abstract class, providing an interface, and should not be instantiated
directly.</p>
<dl class="method">
<dt id="tftpy.TftpPacketTypes.TftpPacket.decode">
<tt class="descname">decode</tt><big>(</big><big>)</big><a class="headerlink" href="#tftpy.TftpPacketTypes.TftpPacket.decode" title="Permalink to this definition">¶</a></dt>
<dd><p>The decode method of a TftpPacket takes a buffer off of the wire in
network-byte order, and decodes it, populating internal properties as
appropriate. This can only be done once the first 2-byte opcode has
already been decoded, but the data section does include the entire
datagram.</p>
<p>This is an abstract method.</p>
</dd></dl>

<dl class="method">
<dt id="tftpy.TftpPacketTypes.TftpPacket.encode">
<tt class="descname">encode</tt><big>(</big><big>)</big><a class="headerlink" href="#tftpy.TftpPacketTypes.TftpPacket.encode" title="Permalink to this definition">¶</a></dt>
<dd><p>The encode method of a TftpPacket takes keyword arguments specific
to the type of packet, and packs an appropriate buffer in network-byte
order suitable for sending over the wire.</p>
<p>This is an abstract method.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tftpy.TftpPacketTypes.TftpPacketACK">
<em class="property">class </em><tt class="descclassname">tftpy.TftpPacketTypes.</tt><tt class="descname">TftpPacketACK</tt><a class="headerlink" href="#tftpy.TftpPacketTypes.TftpPacketACK" title="Permalink to this definition">¶</a></dt>
<dd><div class="highlight-python"><pre>        2 bytes    2 bytes
        -------------------
ACK   | 04    |   Block #  |
        --------------------</pre>
</div>
</dd></dl>

<dl class="class">
<dt id="tftpy.TftpPacketTypes.TftpPacketDAT">
<em class="property">class </em><tt class="descclassname">tftpy.TftpPacketTypes.</tt><tt class="descname">TftpPacketDAT</tt><a class="headerlink" href="#tftpy.TftpPacketTypes.TftpPacketDAT" title="Permalink to this definition">¶</a></dt>
<dd><div class="highlight-python"><pre>        2 bytes    2 bytes       n bytes
        ---------------------------------
DATA  | 03    |   Block #  |    Data    |
        ---------------------------------</pre>
</div>
<dl class="method">
<dt id="tftpy.TftpPacketTypes.TftpPacketDAT.decode">
<tt class="descname">decode</tt><big>(</big><big>)</big><a class="headerlink" href="#tftpy.TftpPacketTypes.TftpPacketDAT.decode" title="Permalink to this definition">¶</a></dt>
<dd>Decode self.buffer into instance variables. It returns self for
easy method chaining.</dd></dl>

<dl class="method">
<dt id="tftpy.TftpPacketTypes.TftpPacketDAT.encode">
<tt class="descname">encode</tt><big>(</big><big>)</big><a class="headerlink" href="#tftpy.TftpPacketTypes.TftpPacketDAT.encode" title="Permalink to this definition">¶</a></dt>
<dd>Encode the DAT packet. This method populates self.buffer, and
returns self for easy method chaining.</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tftpy.TftpPacketTypes.TftpPacketERR">
<em class="property">class </em><tt class="descclassname">tftpy.TftpPacketTypes.</tt><tt class="descname">TftpPacketERR</tt><a class="headerlink" href="#tftpy.TftpPacketTypes.TftpPacketERR" title="Permalink to this definition">¶</a></dt>
<dd><div class="highlight-python"><pre>        2 bytes  2 bytes        string    1 byte
        ----------------------------------------
ERROR | 05    |  ErrorCode |   ErrMsg   |   0  |
        ----------------------------------------

Error Codes

Value     Meaning

0         Not defined, see error message (if any).
1         File not found.
2         Access violation.
3         Disk full or allocation exceeded.
4         Illegal TFTP operation.
5         Unknown transfer ID.
6         File already exists.
7         No such user.
8         Failed to negotiate options</pre>
</div>
<dl class="method">
<dt id="tftpy.TftpPacketTypes.TftpPacketERR.decode">
<tt class="descname">decode</tt><big>(</big><big>)</big><a class="headerlink" href="#tftpy.TftpPacketTypes.TftpPacketERR.decode" title="Permalink to this definition">¶</a></dt>
<dd>Decode self.buffer, populating instance variables and return self.</dd></dl>

<dl class="method">
<dt id="tftpy.TftpPacketTypes.TftpPacketERR.encode">
<tt class="descname">encode</tt><big>(</big><big>)</big><a class="headerlink" href="#tftpy.TftpPacketTypes.TftpPacketERR.encode" title="Permalink to this definition">¶</a></dt>
<dd>Encode the DAT packet based on instance variables, populating
self.buffer, returning self.</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tftpy.TftpPacketTypes.TftpPacketInitial">
<em class="property">class </em><tt class="descclassname">tftpy.TftpPacketTypes.</tt><tt class="descname">TftpPacketInitial</tt><a class="headerlink" href="#tftpy.TftpPacketTypes.TftpPacketInitial" title="Permalink to this definition">¶</a></dt>
<dd><p>This class is a common parent class for the RRQ and WRQ packets, as
they share quite a bit of code.</p>
<dl class="method">
<dt id="tftpy.TftpPacketTypes.TftpPacketInitial.encode">
<tt class="descname">encode</tt><big>(</big><big>)</big><a class="headerlink" href="#tftpy.TftpPacketTypes.TftpPacketInitial.encode" title="Permalink to this definition">¶</a></dt>
<dd>Encode the packet&#8217;s buffer from the instance variables.</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tftpy.TftpPacketTypes.TftpPacketOACK">
<em class="property">class </em><tt class="descclassname">tftpy.TftpPacketTypes.</tt><tt class="descname">TftpPacketOACK</tt><a class="headerlink" href="#tftpy.TftpPacketTypes.TftpPacketOACK" title="Permalink to this definition">¶</a></dt>
<dd><div class="highlight-python"><pre>+-------+---~~---+---+---~~---+---+---~~---+---+---~~---+---+
|  opc  |  opt1  | 0 | value1 | 0 |  optN  | 0 | valueN | 0 |
+-------+---~~---+---+---~~---+---+---~~---+---+---~~---+---+</pre>
</div>
<dl class="method">
<dt id="tftpy.TftpPacketTypes.TftpPacketOACK.match_options">
<tt class="descname">match_options</tt><big>(</big><em>options</em><big>)</big><a class="headerlink" href="#tftpy.TftpPacketTypes.TftpPacketOACK.match_options" title="Permalink to this definition">¶</a></dt>
<dd>This method takes a set of options, and tries to match them with
its own. It can accept some changes in those options from the server as
part of a negotiation. Changed or unchanged, it will return a dict of
the options so that the session can update itself to the negotiated
options.</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tftpy.TftpPacketTypes.TftpPacketRRQ">
<em class="property">class </em><tt class="descclassname">tftpy.TftpPacketTypes.</tt><tt class="descname">TftpPacketRRQ</tt><a class="headerlink" href="#tftpy.TftpPacketTypes.TftpPacketRRQ" title="Permalink to this definition">¶</a></dt>
<dd><div class="highlight-python"><pre>        2 bytes    string   1 byte     string   1 byte
        -----------------------------------------------
RRQ/  | 01/02 |  Filename  |   0  |    Mode    |   0  |
WRQ     -----------------------------------------------</pre>
</div>
</dd></dl>

<dl class="class">
<dt id="tftpy.TftpPacketTypes.TftpPacketWRQ">
<em class="property">class </em><tt class="descclassname">tftpy.TftpPacketTypes.</tt><tt class="descname">TftpPacketWRQ</tt><a class="headerlink" href="#tftpy.TftpPacketTypes.TftpPacketWRQ" title="Permalink to this definition">¶</a></dt>
<dd><div class="highlight-python"><pre>        2 bytes    string   1 byte     string   1 byte
        -----------------------------------------------
RRQ/  | 01/02 |  Filename  |   0  |    Mode    |   0  |
WRQ     -----------------------------------------------</pre>
</div>
</dd></dl>

<dl class="class">
<dt id="tftpy.TftpPacketTypes.TftpPacketWithOptions">
<em class="property">class </em><tt class="descclassname">tftpy.TftpPacketTypes.</tt><tt class="descname">TftpPacketWithOptions</tt><a class="headerlink" href="#tftpy.TftpPacketTypes.TftpPacketWithOptions" title="Permalink to this definition">¶</a></dt>
<dd><p>This class exists to permit some TftpPacket subclasses to share code
regarding options handling. It does not inherit from TftpPacket, as the
goal is just to share code here, and not cause diamond inheritance.</p>
<dl class="method">
<dt id="tftpy.TftpPacketTypes.TftpPacketWithOptions.decode_options">
<tt class="descname">decode_options</tt><big>(</big><em>buffer</em><big>)</big><a class="headerlink" href="#tftpy.TftpPacketTypes.TftpPacketWithOptions.decode_options" title="Permalink to this definition">¶</a></dt>
<dd>This method decodes the section of the buffer that contains an
unknown number of options. It returns a dictionary of option names and
values.</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tftpy.TftpPacketTypes.TftpSession">
<em class="property">class </em><tt class="descclassname">tftpy.TftpPacketTypes.</tt><tt class="descname">TftpSession</tt><a class="headerlink" href="#tftpy.TftpPacketTypes.TftpSession" title="Permalink to this definition">¶</a></dt>
<dd>This class is the base class for the tftp client and server. Any shared
code should be in this class.</dd></dl>

</div>
<div class="section" id="module-tftpy.TftpShared">
<h3>tftpy.TftpShared<a class="headerlink" href="#module-tftpy.TftpShared" title="Permalink to this headline">¶</a></h3>
<p>This module holds all objects shared by all other modules in tftpy.</p>
<dl class="class">
<dt id="tftpy.TftpShared.TftpErrors">
<em class="property">class </em><tt class="descclassname">tftpy.TftpShared.</tt><tt class="descname">TftpErrors</tt><a class="headerlink" href="#tftpy.TftpShared.TftpErrors" title="Permalink to this definition">¶</a></dt>
<dd>This class is a convenience for defining the common tftp error codes,
and making them more readable in the code.</dd></dl>

<dl class="exception">
<dt id="tftpy.TftpShared.TftpException">
<em class="property">exception </em><tt class="descclassname">tftpy.TftpShared.</tt><tt class="descname">TftpException</tt><a class="headerlink" href="#tftpy.TftpShared.TftpException" title="Permalink to this definition">¶</a></dt>
<dd>This class is the parent class of all exceptions regarding the handling
of the TFTP protocol.</dd></dl>

<dl class="function">
<dt id="tftpy.TftpShared.setLogLevel">
<tt class="descclassname">tftpy.TftpShared.</tt><tt class="descname">setLogLevel</tt><big>(</big><em>level</em><big>)</big><a class="headerlink" href="#tftpy.TftpShared.setLogLevel" title="Permalink to this definition">¶</a></dt>
<dd>This function is a utility function for setting the internal log level.
The log level defaults to logging.NOTSET, so unwanted output to stdout is
not created.</dd></dl>

<dl class="function">
<dt id="tftpy.TftpShared.tftpassert">
<tt class="descclassname">tftpy.TftpShared.</tt><tt class="descname">tftpassert</tt><big>(</big><em>condition</em>, <em>msg</em><big>)</big><a class="headerlink" href="#tftpy.TftpShared.tftpassert" title="Permalink to this definition">¶</a></dt>
<dd>This function is a simple utility that will check the condition
passed for a false state. If it finds one, it throws a TftpException
with the message passed. This just makes the code throughout cleaner
by refactoring.</dd></dl>

</div>
<div class="section" id="module-tftpy.TftpStates">
<h3>tftpy.TftpStates<a class="headerlink" href="#module-tftpy.TftpStates" title="Permalink to this headline">¶</a></h3>
<p>This module implements all state handling during uploads and downloads, the
main interface to which being the TftpContext base class and the TftpState
base class.</p>
<p>The concept is simple. Each context object represents a single upload or
download, and the state object in the context object represents the current
state of that transfer. The state object has a handle() method that expects
the next packet in the transfer, and returns a state object until the transfer
is complete, at which point it returns None. That is, unless there is a fatal
error, in which case a TftpException is returned instead.</p>
<dl class="class">
<dt id="tftpy.TftpStates.TftpContext">
<em class="property">class </em><tt class="descclassname">tftpy.TftpStates.</tt><tt class="descname">TftpContext</tt><big>(</big><em>host</em>, <em>port</em>, <em>timeout</em>, <em>dyn_file_func=None</em><big>)</big><a class="headerlink" href="#tftpy.TftpStates.TftpContext" title="Permalink to this definition">¶</a></dt>
<dd><p>The base class of the contexts.</p>
<dl class="method">
<dt id="tftpy.TftpStates.TftpContext.checkTimeout">
<tt class="descname">checkTimeout</tt><big>(</big><em>now</em><big>)</big><a class="headerlink" href="#tftpy.TftpStates.TftpContext.checkTimeout" title="Permalink to this definition">¶</a></dt>
<dd>Compare current time with last_update time, and raise an exception
if we&#8217;re over SOCK_TIMEOUT time.</dd></dl>

<dl class="method">
<dt id="tftpy.TftpStates.TftpContext.cycle">
<tt class="descname">cycle</tt><big>(</big><big>)</big><a class="headerlink" href="#tftpy.TftpStates.TftpContext.cycle" title="Permalink to this definition">¶</a></dt>
<dd>Here we wait for a response from the server after sending it
something, and dispatch appropriate action to that response.</dd></dl>

<dl class="method">
<dt id="tftpy.TftpStates.TftpContext.end">
<tt class="descname">end</tt><big>(</big><big>)</big><a class="headerlink" href="#tftpy.TftpStates.TftpContext.end" title="Permalink to this definition">¶</a></dt>
<dd>Perform session cleanup, since the end method should always be
called explicitely by the calling code, this works better than the
destructor.</dd></dl>

<dl class="method">
<dt id="tftpy.TftpStates.TftpContext.gethost">
<tt class="descname">gethost</tt><big>(</big><big>)</big><a class="headerlink" href="#tftpy.TftpStates.TftpContext.gethost" title="Permalink to this definition">¶</a></dt>
<dd>Simple getter method for use in a property.</dd></dl>

<dl class="attribute">
<dt id="tftpy.TftpStates.TftpContext.host">
<tt class="descname">host</tt><a class="headerlink" href="#tftpy.TftpStates.TftpContext.host" title="Permalink to this definition">¶</a></dt>
<dd>Simple getter method for use in a property.</dd></dl>

<dl class="method">
<dt id="tftpy.TftpStates.TftpContext.sethost">
<tt class="descname">sethost</tt><big>(</big><em>host</em><big>)</big><a class="headerlink" href="#tftpy.TftpStates.TftpContext.sethost" title="Permalink to this definition">¶</a></dt>
<dd>Setter method that also sets the address property as a result
of the host that is set.</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tftpy.TftpStates.TftpContextClientDownload">
<em class="property">class </em><tt class="descclassname">tftpy.TftpStates.</tt><tt class="descname">TftpContextClientDownload</tt><big>(</big><em>host</em>, <em>port</em>, <em>filename</em>, <em>output</em>, <em>options</em>, <em>packethook</em>, <em>timeout</em><big>)</big><a class="headerlink" href="#tftpy.TftpStates.TftpContextClientDownload" title="Permalink to this definition">¶</a></dt>
<dd><p>The download context for the client during a download.
Note: If output is a hyphen, then the output will be sent to stdout.</p>
<dl class="method">
<dt id="tftpy.TftpStates.TftpContextClientDownload.end">
<tt class="descname">end</tt><big>(</big><big>)</big><a class="headerlink" href="#tftpy.TftpStates.TftpContextClientDownload.end" title="Permalink to this definition">¶</a></dt>
<dd>Finish up the context.</dd></dl>

<dl class="method">
<dt id="tftpy.TftpStates.TftpContextClientDownload.start">
<tt class="descname">start</tt><big>(</big><big>)</big><a class="headerlink" href="#tftpy.TftpStates.TftpContextClientDownload.start" title="Permalink to this definition">¶</a></dt>
<dd>Initiate the download.</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tftpy.TftpStates.TftpContextClientUpload">
<em class="property">class </em><tt class="descclassname">tftpy.TftpStates.</tt><tt class="descname">TftpContextClientUpload</tt><big>(</big><em>host</em>, <em>port</em>, <em>filename</em>, <em>input</em>, <em>options</em>, <em>packethook</em>, <em>timeout</em><big>)</big><a class="headerlink" href="#tftpy.TftpStates.TftpContextClientUpload" title="Permalink to this definition">¶</a></dt>
<dd><p>The upload context for the client during an upload.
Note: If input is a hyphen, then we will use stdin.</p>
<dl class="method">
<dt id="tftpy.TftpStates.TftpContextClientUpload.end">
<tt class="descname">end</tt><big>(</big><big>)</big><a class="headerlink" href="#tftpy.TftpStates.TftpContextClientUpload.end" title="Permalink to this definition">¶</a></dt>
<dd>Finish up the context.</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tftpy.TftpStates.TftpContextServer">
<em class="property">class </em><tt class="descclassname">tftpy.TftpStates.</tt><tt class="descname">TftpContextServer</tt><big>(</big><em>host</em>, <em>port</em>, <em>timeout</em>, <em>root</em>, <em>dyn_file_func=None</em><big>)</big><a class="headerlink" href="#tftpy.TftpStates.TftpContextServer" title="Permalink to this definition">¶</a></dt>
<dd><p>The context for the server.</p>
<dl class="method">
<dt id="tftpy.TftpStates.TftpContextServer.end">
<tt class="descname">end</tt><big>(</big><big>)</big><a class="headerlink" href="#tftpy.TftpStates.TftpContextServer.end" title="Permalink to this definition">¶</a></dt>
<dd>Finish up the context.</dd></dl>

<dl class="method">
<dt id="tftpy.TftpStates.TftpContextServer.start">
<tt class="descname">start</tt><big>(</big><em>buffer</em><big>)</big><a class="headerlink" href="#tftpy.TftpStates.TftpContextServer.start" title="Permalink to this definition">¶</a></dt>
<dd>Start the state cycle. Note that the server context receives an
initial packet in its start method. Also note that the server does not
loop on cycle(), as it expects the TftpServer object to manage
that.</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tftpy.TftpStates.TftpMetrics">
<em class="property">class </em><tt class="descclassname">tftpy.TftpStates.</tt><tt class="descname">TftpMetrics</tt><a class="headerlink" href="#tftpy.TftpStates.TftpMetrics" title="Permalink to this definition">¶</a></dt>
<dd><p>A class representing metrics of the transfer.</p>
<dl class="method">
<dt id="tftpy.TftpStates.TftpMetrics.add_dup">
<tt class="descname">add_dup</tt><big>(</big><em>blocknumber</em><big>)</big><a class="headerlink" href="#tftpy.TftpStates.TftpMetrics.add_dup" title="Permalink to this definition">¶</a></dt>
<dd>This method adds a dup for a block number to the metrics.</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tftpy.TftpStates.TftpState">
<em class="property">class </em><tt class="descclassname">tftpy.TftpStates.</tt><tt class="descname">TftpState</tt><big>(</big><em>context</em><big>)</big><a class="headerlink" href="#tftpy.TftpStates.TftpState" title="Permalink to this definition">¶</a></dt>
<dd><p>The base class for the states.</p>
<dl class="method">
<dt id="tftpy.TftpStates.TftpState.handle">
<tt class="descname">handle</tt><big>(</big><em>pkt</em>, <em>raddress</em>, <em>rport</em><big>)</big><a class="headerlink" href="#tftpy.TftpStates.TftpState.handle" title="Permalink to this definition">¶</a></dt>
<dd>An abstract method for handling a packet. It is expected to return
a TftpState object, either itself or a new state.</dd></dl>

<dl class="method">
<dt id="tftpy.TftpStates.TftpState.handleDat">
<tt class="descname">handleDat</tt><big>(</big><em>pkt</em><big>)</big><a class="headerlink" href="#tftpy.TftpStates.TftpState.handleDat" title="Permalink to this definition">¶</a></dt>
<dd>This method handles a DAT packet during a client download, or a
server upload.</dd></dl>

<dl class="method">
<dt id="tftpy.TftpStates.TftpState.handleOACK">
<tt class="descname">handleOACK</tt><big>(</big><em>pkt</em><big>)</big><a class="headerlink" href="#tftpy.TftpStates.TftpState.handleOACK" title="Permalink to this definition">¶</a></dt>
<dd>This method handles an OACK from the server, syncing any accepted
options.</dd></dl>

<dl class="method">
<dt id="tftpy.TftpStates.TftpState.returnSupportedOptions">
<tt class="descname">returnSupportedOptions</tt><big>(</big><em>options</em><big>)</big><a class="headerlink" href="#tftpy.TftpStates.TftpState.returnSupportedOptions" title="Permalink to this definition">¶</a></dt>
<dd>This method takes a requested options list from a client, and
returns the ones that are supported.</dd></dl>

<dl class="method">
<dt id="tftpy.TftpStates.TftpState.sendACK">
<tt class="descname">sendACK</tt><big>(</big><em>blocknumber=None</em><big>)</big><a class="headerlink" href="#tftpy.TftpStates.TftpState.sendACK" title="Permalink to this definition">¶</a></dt>
<dd>This method sends an ack packet to the block number specified. If
none is specified, it defaults to the next_block property in the
parent context.</dd></dl>

<dl class="method">
<dt id="tftpy.TftpStates.TftpState.sendDAT">
<tt class="descname">sendDAT</tt><big>(</big><em>resend=False</em><big>)</big><a class="headerlink" href="#tftpy.TftpStates.TftpState.sendDAT" title="Permalink to this definition">¶</a></dt>
<dd>This method sends the next DAT packet based on the data in the
context. It returns a boolean indicating whether the transfer is
finished.</dd></dl>

<dl class="method">
<dt id="tftpy.TftpStates.TftpState.sendError">
<tt class="descname">sendError</tt><big>(</big><em>errorcode</em><big>)</big><a class="headerlink" href="#tftpy.TftpStates.TftpState.sendError" title="Permalink to this definition">¶</a></dt>
<dd>This method uses the socket passed, and uses the errorcode to
compose and send an error packet.</dd></dl>

<dl class="method">
<dt id="tftpy.TftpStates.TftpState.sendOACK">
<tt class="descname">sendOACK</tt><big>(</big><big>)</big><a class="headerlink" href="#tftpy.TftpStates.TftpState.sendOACK" title="Permalink to this definition">¶</a></dt>
<dd>This method sends an OACK packet with the options from the current
context.</dd></dl>

<dl class="method">
<dt id="tftpy.TftpStates.TftpState.serverInitial">
<tt class="descname">serverInitial</tt><big>(</big><em>pkt</em>, <em>raddress</em>, <em>rport</em><big>)</big><a class="headerlink" href="#tftpy.TftpStates.TftpState.serverInitial" title="Permalink to this definition">¶</a></dt>
<dd>This method performs initial setup for a server context transfer,
put here to refactor code out of the TftpStateServerRecvRRQ and
TftpStateServerRecvWRQ classes, since their initial setup is
identical. The method returns a boolean, sendoack, to indicate whether
it is required to send an OACK to the client.</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tftpy.TftpStates.TftpStateExpectACK">
<em class="property">class </em><tt class="descclassname">tftpy.TftpStates.</tt><tt class="descname">TftpStateExpectACK</tt><big>(</big><em>context</em><big>)</big><a class="headerlink" href="#tftpy.TftpStates.TftpStateExpectACK" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents the state of the transfer when a DAT was just
sent, and we are waiting for an ACK from the server. This class is the
same one used by the client during the upload, and the server during the
download.</p>
<dl class="method">
<dt id="tftpy.TftpStates.TftpStateExpectACK.handle">
<tt class="descname">handle</tt><big>(</big><em>pkt</em>, <em>raddress</em>, <em>rport</em><big>)</big><a class="headerlink" href="#tftpy.TftpStates.TftpStateExpectACK.handle" title="Permalink to this definition">¶</a></dt>
<dd>Handle a packet, hopefully an ACK since we just sent a DAT.</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tftpy.TftpStates.TftpStateExpectDAT">
<em class="property">class </em><tt class="descclassname">tftpy.TftpStates.</tt><tt class="descname">TftpStateExpectDAT</tt><big>(</big><em>context</em><big>)</big><a class="headerlink" href="#tftpy.TftpStates.TftpStateExpectDAT" title="Permalink to this definition">¶</a></dt>
<dd><p>Just sent an ACK packet. Waiting for DAT.</p>
<dl class="method">
<dt id="tftpy.TftpStates.TftpStateExpectDAT.handle">
<tt class="descname">handle</tt><big>(</big><em>pkt</em>, <em>raddress</em>, <em>rport</em><big>)</big><a class="headerlink" href="#tftpy.TftpStates.TftpStateExpectDAT.handle" title="Permalink to this definition">¶</a></dt>
<dd>Handle the packet in response to an ACK, which should be a DAT.</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tftpy.TftpStates.TftpStateSentRRQ">
<em class="property">class </em><tt class="descclassname">tftpy.TftpStates.</tt><tt class="descname">TftpStateSentRRQ</tt><big>(</big><em>context</em><big>)</big><a class="headerlink" href="#tftpy.TftpStates.TftpStateSentRRQ" title="Permalink to this definition">¶</a></dt>
<dd><p>Just sent an RRQ packet.</p>
<dl class="method">
<dt id="tftpy.TftpStates.TftpStateSentRRQ.handle">
<tt class="descname">handle</tt><big>(</big><em>pkt</em>, <em>raddress</em>, <em>rport</em><big>)</big><a class="headerlink" href="#tftpy.TftpStates.TftpStateSentRRQ.handle" title="Permalink to this definition">¶</a></dt>
<dd>Handle the packet in response to an RRQ to the server.</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tftpy.TftpStates.TftpStateSentWRQ">
<em class="property">class </em><tt class="descclassname">tftpy.TftpStates.</tt><tt class="descname">TftpStateSentWRQ</tt><big>(</big><em>context</em><big>)</big><a class="headerlink" href="#tftpy.TftpStates.TftpStateSentWRQ" title="Permalink to this definition">¶</a></dt>
<dd><p>Just sent an WRQ packet for an upload.</p>
<dl class="method">
<dt id="tftpy.TftpStates.TftpStateSentWRQ.handle">
<tt class="descname">handle</tt><big>(</big><em>pkt</em>, <em>raddress</em>, <em>rport</em><big>)</big><a class="headerlink" href="#tftpy.TftpStates.TftpStateSentWRQ.handle" title="Permalink to this definition">¶</a></dt>
<dd>Handle a packet we just received.</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tftpy.TftpStates.TftpStateServerRecvRRQ">
<em class="property">class </em><tt class="descclassname">tftpy.TftpStates.</tt><tt class="descname">TftpStateServerRecvRRQ</tt><big>(</big><em>context</em><big>)</big><a class="headerlink" href="#tftpy.TftpStates.TftpStateServerRecvRRQ" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents the state of the TFTP server when it has just
received an RRQ packet.</p>
<dl class="method">
<dt id="tftpy.TftpStates.TftpStateServerRecvRRQ.handle">
<tt class="descname">handle</tt><big>(</big><em>pkt</em>, <em>raddress</em>, <em>rport</em><big>)</big><a class="headerlink" href="#tftpy.TftpStates.TftpStateServerRecvRRQ.handle" title="Permalink to this definition">¶</a></dt>
<dd>Handle an initial RRQ packet as a server.</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tftpy.TftpStates.TftpStateServerRecvWRQ">
<em class="property">class </em><tt class="descclassname">tftpy.TftpStates.</tt><tt class="descname">TftpStateServerRecvWRQ</tt><big>(</big><em>context</em><big>)</big><a class="headerlink" href="#tftpy.TftpStates.TftpStateServerRecvWRQ" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents the state of the TFTP server when it has just
received a WRQ packet.</p>
<dl class="method">
<dt id="tftpy.TftpStates.TftpStateServerRecvWRQ.handle">
<tt class="descname">handle</tt><big>(</big><em>pkt</em>, <em>raddress</em>, <em>rport</em><big>)</big><a class="headerlink" href="#tftpy.TftpStates.TftpStateServerRecvWRQ.handle" title="Permalink to this definition">¶</a></dt>
<dd>Handle an initial WRQ packet as a server.</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tftpy.TftpStates.TftpStateServerStart">
<em class="property">class </em><tt class="descclassname">tftpy.TftpStates.</tt><tt class="descname">TftpStateServerStart</tt><big>(</big><em>context</em><big>)</big><a class="headerlink" href="#tftpy.TftpStates.TftpStateServerStart" title="Permalink to this definition">¶</a></dt>
<dd><p>The start state for the server. This is a transitory state since at
this point we don&#8217;t know if we&#8217;re handling an upload or a download. We
will commit to one of them once we interpret the initial packet.</p>
<dl class="method">
<dt id="tftpy.TftpStates.TftpStateServerStart.handle">
<tt class="descname">handle</tt><big>(</big><em>pkt</em>, <em>raddress</em>, <em>rport</em><big>)</big><a class="headerlink" href="#tftpy.TftpStates.TftpStateServerStart.handle" title="Permalink to this definition">¶</a></dt>
<dd>Handle a packet we just received.</dd></dl>

</dd></dl>

</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h3><a href="#">Table Of Contents</a></h3>
            <ul>
<li><a class="reference external" href="#">Welcome to TFTPy&#8217;s documentation!</a><ul>
</ul>
</li>
<li><a class="reference external" href="#indices-and-tables">Indices and tables</a></li>
<li><a class="reference external" href="#api-documentation">API Documentation</a><ul>
<li><a class="reference external" href="#front-end-modules">Front-end Modules</a><ul>
<li><a class="reference external" href="#module-tftpy">TFTPy Module</a></li>
<li><a class="reference external" href="#module-tftpy.TftpClient">tftpy.TftpClient</a></li>
<li><a class="reference external" href="#module-tftpy.TftpServer">tftpy.TftpServer</a></li>
</ul>
</li>
<li><a class="reference external" href="#back-end-modules">Back-end Modules</a><ul>
<li><a class="reference external" href="#module-tftpy.TftpPacketFactory">tftpy.TftpPacketFactory</a></li>
<li><a class="reference external" href="#module-tftpy.TftpPacketTypes">tftpy.TftpPacketTypes</a></li>
<li><a class="reference external" href="#module-tftpy.TftpShared">tftpy.TftpShared</a></li>
<li><a class="reference external" href="#module-tftpy.TftpStates">tftpy.TftpStates</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="_sources/index.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="search.html" method="get">
                <input type="text" name="q" size="18" />
                <input type="submit" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="modindex.html" title="Global Module Index"
             >modules</a> |</li>
        <li><a href="#">TFTPy v0.5.1 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
      &copy; Copyright 2010, Michael P. Soulier.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 0.6.5.
    </div>
  </body>
</html>